"""
Quaternion UKF
^^^^^^^^^^^^^^

This implementation of a UKF for tracking orientation of a drone with gyro and accelerometer
data follows closely that described in the paper "A Quaternion-based Unscented Kalman Filter for
Orientation Tracking" by Edgar Kraft.

This project was completed as part of ESE 650: Learning in Robotics at the University of
Pennsylvania, though it has been tweaked, and additional infrastructure has been built since then.

Most notably, despite that the initial implementation passed all tests for that project, I am
certain that parts of it were incorrect. Comparing the results, I'm fairly sure that the updated
version would not have passed the TAs' unit tests despite being correct, or at least better.

I think this because my initial version was highly sensitive to my process model noise, which
I tuned to the thousandth decimal place to be able to pass all tests. That's indicative that
version was flawed.

The updated version has fixed the instabilities that existed at pi and -pi, and it's no longer
so sensitive to how I choose to model the process noise. That being said, I'm always on the
lookout for ways the updated implementation can improve.

Here's an example of how this can be used with some toy data generated by the some of the
new infrastructure I've built to test this new implementation:

.. code-block::
   :linenos:

   import numpy as np
   from estimator.constants import STATE_DOF

   # Set measurement and process model noise to something reasonable
   R = np.identity(STATE_DOF) * .1
   Q = np.copy(R)

   # Build some toy data with rudimentary model of noise and drift in the sensor data
   planner = RoundTripPlanner()
   data_source = DataMaker(planner)

   # Filter the data and plot the comparison
   estimator = QuaternionUkf(data_source, R, Q)
   estimator.estimate_state()
   estimator.plot_comparison(
       estimator.rots,
       estimator.ts_imu,
       data_source.rots_vicon,
       data_source.ts_vicon
   )
"""

import argparse

import numpy as np

from estimator.constants import STATE_DOF
from estimator.data.datamaker import DataMaker
from estimator.data.datastore import DataStore
from estimator.data.trajectoryplanner import RoundTripPlanner
from estimator.quaternions import Quaternions
from estimator.state_estimator import StateEstimator


class QuaternionUkf(StateEstimator):
    """
    Estimates rotational position/velocity state of robot from time series data

    :cvar G_VECTOR: normalized 3D gravity vector
    :ivar measurement_noise: estimated noise in a given sensor measurement
    :ivar process_noise: estimated noise involved in a given step of the process model
    :ivar state: (7, :py:meth:`~estimator.state_estimator.StateEstimator.num_data`)
                 numpy array of state vectors the first 4 elements of which are a
                 quaternion and the latter three an angular velocity vector
    :ivar covariance: (6, 6, :py:meth:`~estimator.state_estimator.StateEstimator.num_data`)
                      numpy array of the estimated covariance of each degree of freedom in
                      the state
    """

    G_VECTOR = np.array([0, 0, 1])

    def __init__(self, source, measurement_noise, process_noise):

        super().__init__(source)

        self.measurement_noise = measurement_noise
        self.process_noise = process_noise

        # Initialize covariance history and state history
        self.state = np.zeros((STATE_DOF + 1, self.imu_data.shape[-1]))
        self.state[:, 0] = np.array([1, 0, 0, 0, 0, 0, 0])
        self.covariance = np.zeros((STATE_DOF, STATE_DOF, self.state.shape[-1]))
        self.covariance[..., 0] = np.identity(STATE_DOF) * .01

        # Keep track of time during filtering for debugging purposes
        self._t = 0

    def estimate_state(self):
        """
        Uses data provided by the source to estimate the state history of the filter
        After calling this function, the state and rotation history will be defined
        """

        self.imu_data[:3] = self._normalize_data(self.imu_data[:3])

        self.rots = np.zeros((3, 3, self.state.shape[-1]))
        self.rots[..., 0] = Quaternions(self.state[:4, 0]).to_rotation_matrix()

        for i in range(1, self.state.shape[-1]):
            dt = self.ts_imu[i] - self.ts_imu[i - 1]
            self._t = self.ts_imu[i]

            self.state[:, i], self.covariance[..., i] = self._filter_next(
                self.covariance[..., i - 1],
                self.state[:, i - 1],
                self.imu_data[:, i],
                dt
            )
            self.rots[..., i] = Quaternions(self.state[:4, i]).to_rotation_matrix()

    def _debug_print(self, t_min, interval, *contents):
        """
        Prints contents to the terminal for the specified period of time
        """
        if t_min <= self._t <= t_min + interval:
            print("Time {} seconds".format(self._t))
            for content in contents:
                print(content)

    def _calc_sigma_distances(self, cov_last):
        """
        Calculates distances by which to disturb the state vector to obtain sigma points

        :param cov_last: estimated state covariance matrix at the previous timestep
        """
        cov_muliplier = STATE_DOF
        positive_offsets = np.linalg.cholesky(cov_muliplier * (cov_last + self.process_noise))
        offsets = np.concatenate((positive_offsets, -positive_offsets), axis=1)
        return np.concatenate((np.zeros((STATE_DOF, 1)), offsets), axis=1)

    def _filter_next(self, cov_last, state_last, measurement_this, dt):  # pylint: disable=too-many-locals

        sigma_offset = self._calc_sigma_distances(cov_last)

        # Equation 34: Form sigma points based on prior mean and covariance data
        quats_offset = Quaternions.from_vectors(sigma_offset[:3])
        quat_last = Quaternions(state_last[:4])
        quats_sigpt = quats_offset.q_multiply(quat_last)

        vels_offset = sigma_offset[3:]
        vel_last = state_last[4:]
        vels_projected = vel_last.reshape(-1, 1) + vels_offset

        # Equations 9-11: Form quaternion projection
        quat_delta = Quaternions.from_vectors(vels_projected * dt)

        # Equation 22: Apply non-linear function A with process noise of zero
        quats_projected = quat_delta.q_multiply(quats_sigpt)

        # Equations 52-55: Use mean-finding algorithm to satisfy Equation 38
        quat_state_est = quats_projected.find_q_mean(quats_projected[0])
        vel_state_est = np.mean(vels_projected, axis=1)

        # Equations 65-67: Find the predicted process model error from the estimated state
        orientations_error = quat_state_est.inverse().q_multiply(quats_projected).to_vectors()
        vels_error = vels_projected - vel_state_est.reshape(-1, 1)
        process_model_error = np.concatenate((orientations_error, vels_error))

        # Equation 64: Estimate covariance matrix as covariance of process model
        cov_this_est = process_model_error @ process_model_error.T
        cov_this_est /= sigma_offset.shape[1]

        # Equation 27 and 40: Estimate measurements that are expected given the process model
        gs_est = quats_projected.rotate_vector(self.G_VECTOR)
        measurements_est = np.concatenate((gs_est, vels_projected))

        # Equation 48: Take the mean of expected measurements as the estimated measurement
        measurement_est = np.mean(measurements_est, axis=1)

        # Equation 68, 70: Calculate measurement covariance and cross-correlation
        measurement_error = measurements_est - measurement_est.reshape(-1, 1)
        cov_measurement = measurement_error @ measurement_error.T
        cross_correlation = process_model_error @ measurement_error.T
        cov_measurement /= sigma_offset.shape[1]
        cross_correlation /= sigma_offset.shape[1]

        # Equation 69: Include the noise from the measurement model in estimated covariance
        cov_innovation = cov_measurement + self.measurement_noise

        # Equation 72: Kalman gain as cross correlation to measurement covariance ratio
        kalman_gain = cross_correlation @ np.linalg.inv(cov_innovation)

        # Equation 74: Obtain quaternion and velocity parts of measurement correction
        innovation = (measurement_this - measurement_est).reshape(-1, 1)
        correction = np.matmul(kalman_gain, innovation).reshape(-1)
        quat_correction = Quaternions.from_vectors(correction[:3])
        vel_correction = correction[3:]

        # Equation 46: Apply the measurement correction to the estimate from the process model
        state_this = np.zeros(STATE_DOF + 1)
        state_this[:4] = quat_state_est.q_multiply(quat_correction).array
        state_this[4:] = vel_state_est + vel_correction

        # Equation 75: Update the covariance estimate given this measurement update
        cov_this = cov_this_est - kalman_gain @ cov_innovation @ kalman_gain.T

        return state_this, cov_this


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-D",
        "--datanum",
        required=False, help="Number of data file (1 to 3 inclusive)"
    )

    args = vars(parser.parse_args())

    # Noise parameters for UKF
    R = np.identity(STATE_DOF) * .1
    Q = np.copy(R)
    # Q[3:, 3:] *= 10

    num = args["datanum"]
    if not num:
        planner = RoundTripPlanner()
        data_source = DataMaker(planner)
    else:
        data_source = DataStore(dataset_number=num, path_to_data="estimator/data/")

    estimator = QuaternionUkf(data_source, R, Q)
    estimator.estimate_state()

    estimator.plot_comparison(
        estimator.rots,
        estimator.ts_imu,
        data_source.rots_vicon,
        data_source.ts_vicon
    )
